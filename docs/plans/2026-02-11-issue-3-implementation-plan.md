# Issue #3: DO shell generation — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Generate `gen/do.js` during compilation — a Cloudflare Durable Object shell that imports Haxe-compiled server code and routes `/rpc` requests.

**Architecture:** Static endpoint accumulator populated during `process()`, `@:expose`/`@:keep` metadata injection on server build, `onAfterGenerate` hook emits `do.js` and patches `server.js` to use `globalThis`.

**Tech Stack:** Haxe 4.3.6 macros, `sys.io.File` for file I/O in `onAfterGenerate`.

**Working directory:** `/home/mikesol/Documents/GitHub/h4x0r/h4x0r-3` (worktree on branch `issue-3`)

---

### Task 1: Add static endpoint accumulator and metadata injection

**Files:**
- Modify: `src/h4x0r/Build.hx`

**Step 1: Add endpoint accumulator**

Add a static var to Build:

```haxe
private typedef ServerEndpoint = {
    className:String,
    methodName:String,
    args:Array<String>,
};

// In Build class:
static var serverEndpoints:Array<ServerEndpoint> = [];
```

**Step 2: Populate during process()**

In the `process()` function, after classification, when placement is `ServerBound` on the server build:

```haxe
#if h4x0r_server
if (placement == ServerBound) {
    // Collect endpoint for DO shell generation
    var argNames = switch (field.kind) {
        case FFun(f): [for (a in f.args) a.name];
        default: [];
    };
    serverEndpoints.push({
        className: className,
        methodName: field.name,
        args: argNames,
    });
}
#end
```

**Step 3: Add @:expose to class on server build**

In `process()`, add class-level metadata (once per class, before the field loop):

```haxe
#if h4x0r_server
var classMeta = Context.getLocalClass().get().meta;
// Only add @:expose if not already present
var hasExpose = false;
if (classMeta != null) {
    for (m in classMeta.get()) {
        if (m.name == ":expose") hasExpose = true;
    }
}
if (!hasExpose) {
    classMeta.add(":expose", [macro $v{className}], Context.currentPos());
}
#end
```

**Step 4: Add @:keep to server-bound methods on server build**

In the field loop, when placement is ServerBound:

```haxe
#if h4x0r_server
if (placement == ServerBound) {
    if (field.meta == null) field.meta = [];
    field.meta.push({name: ":keep", params: null, pos: field.pos});
}
#end
```

**Step 5: Compile and verify**

Run: `haxe build.hxml 2>&1`

Check `gen/server.js` for:
- `$global.TestApp = TestApp` (from @:expose)
- Server-bound methods present (from @:keep): `fetchData`, `sendReport`, `audit`

**Step 6: Commit**

```bash
git add src/h4x0r/Build.hx
git commit -m "feat(#3): endpoint accumulator and @:expose/@:keep metadata injection"
```

---

### Task 2: Register onAfterGenerate and implement DO shell emission

**Files:**
- Modify: `src/h4x0r/Build.hx`

**Step 1: Update configure() to register onAfterGenerate**

```haxe
public static function configure() {
    #if h4x0r_server
    Context.onAfterGenerate(function() {
        patchServerExports();
        emitDOShell();
    });
    #end
}
```

Note: `Context` is `haxe.macro.Context`. The import is already at the top of the file.

**Step 2: Implement patchServerExports()**

Reads `gen/server.js` and replaces the IIFE's `})({})` at the end with `})(globalThis)`:

```haxe
static function patchServerExports():Void {
    var path = "gen/server.js";
    try {
        var content = sys.io.File.getContent(path);
        // Replace the IIFE global parameter: })({}) → })(globalThis)
        // The Haxe JS output ends with })({});\n or similar
        content = StringTools.replace(content, "})({});", "})(globalThis);");
        sys.io.File.saveContent(path, content);
        trace('[h4x0r] patched $path: $global → globalThis');
    } catch (e:Dynamic) {
        trace('[h4x0r] WARNING: could not patch $path: $e');
        trace('[h4x0r] gen/do.js may not be able to import server classes');
    }
}
```

**Step 3: Implement emitDOShell()**

Generates `gen/do.js` from collected endpoints:

```haxe
static function emitDOShell():Void {
    if (serverEndpoints.length == 0) {
        trace('[h4x0r] no server endpoints found, skipping do.js generation');
        return;
    }

    var buf = new StringBuf();
    buf.add("// gen/do.js — generated by h4x0r. Do not edit.\n");
    buf.add("import './server.js';\n\n");

    // Determine class name (assume single app class for Phase 1)
    var appClassName = serverEndpoints[0].className;
    var doClassName = appClassName + "DO";

    buf.add('export class $doClassName {\n');
    buf.add('  constructor(state, env) {\n');
    buf.add('    this.state = state;\n');
    buf.add('    this.storage = state.storage;\n');
    buf.add('    this.env = env;\n');
    buf.add('    this.app = new globalThis.$appClassName();\n');
    buf.add('  }\n\n');

    buf.add('  async fetch(request) {\n');
    buf.add("    if (request.method !== 'POST') {\n");
    buf.add("      return new Response('Method not allowed', { status: 405 });\n");
    buf.add('    }\n');
    buf.add('    const url = new URL(request.url);\n');
    buf.add("    if (url.pathname !== '/rpc') {\n");
    buf.add("      return new Response('Not found', { status: 404 });\n");
    buf.add('    }\n');
    buf.add('    const { method, args } = await request.json();\n');
    buf.add('    switch (method) {\n');

    for (ep in serverEndpoints) {
        var qualifiedName = ep.className + "." + ep.methodName;
        var argList = [for (a in ep.args) 'args.$a'].join(", ");
        buf.add("      case '$qualifiedName':\n");
        buf.add('        return json(this.app.${ep.methodName}($argList));\n');
    }

    buf.add('      default:\n');
    buf.add("        return new Response(JSON.stringify({error: 'Unknown method: ' + method}), {\n");
    buf.add("          status: 404, headers: {'Content-Type': 'application/json'}\n");
    buf.add('        });\n');
    buf.add('    }\n');
    buf.add('  }\n');
    buf.add('}\n\n');

    buf.add('function json(data) {\n');
    buf.add('  return new Response(JSON.stringify(data), {\n');
    buf.add("    headers: {'Content-Type': 'application/json'}\n");
    buf.add('  });\n');
    buf.add('}\n');

    var content = buf.toString();
    sys.io.File.saveContent("gen/do.js", content);
    trace('[h4x0r] wrote gen/do.js with ${serverEndpoints.length} endpoints');
}
```

Note: Haxe string interpolation uses `'$var'` or `'${expr}'` in single-quoted strings. The `buf.add()` calls use Haxe string interpolation to embed the variable values. Be careful with quoting — JS strings inside `buf.add()` that should be literal (not interpolated) need to use double quotes or escaped single quotes in the Haxe source.

**Step 4: Compile and verify**

Run: `haxe build.hxml 2>&1`

Expected trace output includes:
```
[h4x0r] patched gen/server.js: $global → globalThis
[h4x0r] wrote gen/do.js with 3 endpoints
```

Check that `gen/do.js` exists and contains:
- `import './server.js'`
- `export class TestAppDO`
- Switch cases for `TestApp.fetchData`, `TestApp.sendReport`, `TestApp.audit`

Check that `gen/server.js` ends with `})(globalThis);` instead of `})({});`

Run: `node --check gen/do.js` — Note: this will fail because `import` is ES module syntax and Node requires `--input-type=module` or `.mjs` extension. Instead verify with: `node -e "import('./gen/do.js').catch(e => console.log(e.message))"` or just check that the JS syntax is well-formed by visual inspection.

**Step 5: Commit**

```bash
git add src/h4x0r/Build.hx
git commit -m "feat(#3): generate gen/do.js via onAfterGenerate"
```

---

### Task 3: End-to-end verification

**Files:**
- No changes — verification only

**Step 1: Verify all acceptance criteria**

1. `gen/do.js` is emitted during compilation — check file exists
2. DO shell imports from `./server.js` — check first lines
3. Each server-bound method has a route — grep for case statements
4. Request body JSON is parsed — check `await request.json()`
5. Response is JSON-serialized — check `json()` helper
6. Valid JS for Cloudflare — visual inspection of ES module syntax

**Step 2: Verify server.js has exposed class and kept methods**

Check `gen/server.js` contains:
- `$global.TestApp = TestApp` (or `globalThis.TestApp = TestApp` after patching)
- `fetchData`, `sendReport`, `audit` methods present

**Step 3: Verify client.js is unaffected**

The `onAfterGenerate` hook only runs on server build. Client build should be identical to before.

**Step 4: Final commit**

```bash
git add -A
git commit -m "feat(#3): generate DO shell (gen/do.js) importing Haxe-compiled server.js

Emits gen/do.js via onAfterGenerate — a thin Cloudflare Durable Object
shell that imports gen/server.js and routes POST /rpc requests to the
appropriate Haxe methods.

- @:expose makes app class available on globalThis
- @:keep prevents DCE of server-bound methods
- server.js IIFE patched to use globalThis instead of {}
- DO shell has switch-based routing matching client proxy stubs

Closes #3"
```

---

## Notes

- **String interpolation in emitDOShell:** The Haxe code generating JS strings needs careful quoting. Haxe's `'$var'` interpolation applies in single-quoted strings. Use double quotes for literal JS content, single quotes for Haxe-interpolated strings.

- **onAfterGenerate timing risk:** If `gen/server.js` isn't written yet when the callback runs, `patchServerExports()` will fail gracefully (try/catch). Fallback: skip the patch and instead generate a wrapper file. Implementation should test this.

- **Single app class assumption:** Phase 1 assumes one `@:build`-annotated class per compilation. The endpoint accumulator records className, so multi-class support is forward-compatible.
